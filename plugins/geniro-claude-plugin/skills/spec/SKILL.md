---
name: spec
description: "Conduct a structured requirements interview before architecture. Three rounds: general understanding, code-informed questions, edge cases. Produces a clear requirements spec that validates completeness before proceeding to architecture. Use before /orchestrate or /plan for non-trivial features."
allowed-tools:
  - Read
  - Glob
  - Grep
  - Bash
  - Task
  - AskUserQuestion
argument-hint: "[feature or problem description]"
---

# Requirements Gathering — Structured Interview

You are conducting a structured requirements interview for the Geniro platform. Your goal is to produce a complete, unambiguous requirements specification before any architecture or implementation begins.

## Feature Request

$ARGUMENTS

## Interview Protocol

### CRITICAL: Use AskUserQuestion for ALL questions

**NEVER present questions as plain text.** Always use the `AskUserQuestion` tool so the user can select from predefined choices instead of typing.

For every question you ask:
1. **Formulate 2–4 concrete answer options** based on your understanding of the feature and codebase patterns
2. **Use short, descriptive labels** for each option (1–5 words)
3. **Add a description** explaining the implications of each choice
4. **Use `multiSelect: true`** when multiple options can apply simultaneously
5. **Always include a meaningful "Other" implicitly** — the tool adds it automatically for custom input
6. **Group related questions** — you can ask up to 4 questions per `AskUserQuestion` call
7. **Use the `header` field** for a short category label (e.g., "Scope", "Priority", "Data model")

**Example — instead of asking:**
> "Should this feature support real-time updates via WebSocket, or is polling sufficient?"

**Use AskUserQuestion with options:**
- Label: "WebSocket (real-time)", Description: "Push updates instantly via existing Socket.IO infrastructure"
- Label: "Polling", Description: "Client polls API periodically, simpler but adds latency"
- Label: "Both", Description: "WebSocket primary, polling as fallback"

### Round 1: General Understanding

Based on the feature description, ask the user clarifying questions about:

- **Goals**: What problem does this solve? Who benefits?
- **Scope**: What's in scope vs explicitly out of scope?
- **Success criteria**: How do we know this is done correctly?
- **Priority**: Must-have vs nice-to-have aspects
- **Constraints**: Performance requirements, backward compatibility, deadlines

Present **3–7 focused questions** via `AskUserQuestion`. Do not ask obvious questions the description already answers. Do not ask questions you can answer yourself by reading the codebase. Provide concrete answer choices for each question based on common patterns.

Wait for the user to respond before proceeding to Round 2.

### Round 2: Code-Informed Questions

After Round 1 answers, **explore the relevant parts of both codebases**:

**API (geniro/):**
- Search for existing features similar to what's being requested
- Check relevant entities, services, and controllers
- Look at database schema implications
- Check existing notification/WebSocket patterns if relevant

**Web (geniro-web/):**
- Search for existing UI patterns similar to what's being requested
- Check relevant pages, components, and hooks
- Look at `src/autogenerated/` for available API types
- Check existing state management patterns

Based on what you find in the code, ask the user questions about:

- **Integration points**: How this connects to existing features you found
- **Data model**: What entities/fields are involved (informed by actual schema)
- **UI/UX**: Specific interaction patterns, where in the app this lives
- **Migration**: How existing data/users transition to the new behavior
- **Existing patterns**: Whether to reuse or diverge from patterns you found

Present **3–5 code-informed questions** via `AskUserQuestion`. Reference specific files/patterns you found. Use your codebase findings to create informed answer choices (e.g., "Reuse GraphEntity pattern" vs "New standalone entity").

Wait for the user to respond before proceeding to Round 3.

### Round 3: Edge Cases

After Round 2 answers, present a comprehensive edge case checklist via `AskUserQuestion` with `multiSelect: true`. Group related edge cases and let the user select which ones apply:

- **Error states**: What happens when things fail (network, validation, permissions)
- **Concurrent access**: Multiple users/agents operating on the same resource
- **Permission/auth**: Who can do what, access control boundaries
- **Empty/null/boundary**: No data, maximum data, first-time experience
- **Backward compatibility**: How existing data, API clients, and users are affected
- **Real-time sync**: WebSocket event implications, race conditions

For each question, propose your recommended handling as the first option (with "(Recommended)" suffix), and offer alternatives. The user picks which approach they prefer.

Wait for the user to respond before producing the spec.

## Output: Requirements Specification

After all three rounds, produce the final spec:

```markdown
# Requirements Spec: [Feature Name]

**Date**: [today's date]
**Status**: Draft — pending user confirmation

## Problem Statement
[1-2 sentences describing the problem and who it affects]

## Requirements

### Must-Have
1. [R1: requirement with clear acceptance criterion]
2. [R2: requirement with clear acceptance criterion]
...

### Nice-to-Have
1. [requirement with acceptance criterion]
...

## Scope

### In Scope
- [specific deliverable]
...

### Out of Scope
- [explicitly excluded item with reason]
...

## Data Model Impact
- [entity changes, new fields, migrations needed]

## API Changes
- [new/modified endpoints, request/response shapes]

## UI Changes
- [new/modified pages, components, interactions]

## Edge Cases & Error Handling
1. [edge case] — [expected behavior]
2. ...

## Success Criteria
1. [measurable, testable criterion]
2. ...

## Constraints
- [technical, timeline, or compatibility constraints]

## Open Questions
- [anything still unresolved — should be empty if interview was thorough]
```

Present the spec to the user for final confirmation. If they approve, it's ready to pass to `/orchestrate` or `/plan`.

## Rules

- **ALWAYS use AskUserQuestion** — never present interview questions as plain text. Every question must have selectable choices so the user can click instead of type
- **Be concise in questions** — 1-2 sentences per question, not paragraphs
- **Don't repeat information** — if the user already stated something, reference it, don't ask again
- **Don't over-interview** — if the feature is straightforward, skip unnecessary rounds
- **Be opinionated** — propose sensible defaults as the first option (with "(Recommended)") instead of asking open-ended "what should happen here?"
- **Ground questions in code** — Round 2 questions should reference actual files and patterns you found, not hypothetical concerns
