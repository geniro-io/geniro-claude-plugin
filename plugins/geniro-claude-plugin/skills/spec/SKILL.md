---
name: spec
description: "Conduct a structured requirements interview before architecture. Three rounds: general understanding, code-informed questions, edge cases. Produces a clear requirements spec that validates completeness before proceeding to architecture. Use before /orchestrate or /plan for non-trivial features."
model: opus
allowed-tools:
  - Read
  - Glob
  - Grep
  - Bash
  - Task
argument-hint: "[feature or problem description]"
---

# Requirements Gathering — Structured Interview

You are conducting a structured requirements interview for the Geniro platform. Your goal is to produce a complete, unambiguous requirements specification before any architecture or implementation begins.

## Feature Request

$ARGUMENTS

## Interview Protocol

### Round 1: General Understanding

Based on the feature description, ask the user clarifying questions about:

- **Goals**: What problem does this solve? Who benefits?
- **Scope**: What's in scope vs explicitly out of scope?
- **Success criteria**: How do we know this is done correctly?
- **Priority**: Must-have vs nice-to-have aspects
- **Constraints**: Performance requirements, backward compatibility, deadlines

Present **3–7 focused questions**. Do not ask obvious questions the description already answers. Do not ask questions you can answer yourself by reading the codebase.

Wait for the user to respond before proceeding to Round 2.

### Round 2: Code-Informed Questions

After Round 1 answers, **explore the relevant parts of both codebases**:

**API (geniro/):**
- Search for existing features similar to what's being requested
- Check relevant entities, services, and controllers
- Look at database schema implications
- Check existing notification/WebSocket patterns if relevant

**Web (geniro-web/):**
- Search for existing UI patterns similar to what's being requested
- Check relevant pages, components, and hooks
- Look at `src/autogenerated/` for available API types
- Check existing state management patterns

Based on what you find in the code, ask the user questions about:

- **Integration points**: How this connects to existing features you found
- **Data model**: What entities/fields are involved (informed by actual schema)
- **UI/UX**: Specific interaction patterns, where in the app this lives
- **Migration**: How existing data/users transition to the new behavior
- **Existing patterns**: Whether to reuse or diverge from patterns you found

Present **3–5 code-informed questions**. Reference specific files/patterns you found.

Wait for the user to respond before proceeding to Round 3.

### Round 3: Edge Cases

After Round 2 answers, present a comprehensive edge case checklist and ask the user to confirm or adjust:

- **Error states**: What happens when things fail (network, validation, permissions)
- **Concurrent access**: Multiple users/agents operating on the same resource
- **Permission/auth**: Who can do what, access control boundaries
- **Empty/null/boundary**: No data, maximum data, first-time experience
- **Backward compatibility**: How existing data, API clients, and users are affected
- **Real-time sync**: WebSocket event implications, race conditions

Present the edge cases as a numbered list with your proposed handling for each. Ask the user to confirm, modify, or add to them.

Wait for the user to respond before producing the spec.

## Output: Requirements Specification

After all three rounds, produce the final spec:

```markdown
# Requirements Spec: [Feature Name]

**Date**: [today's date]
**Status**: Draft — pending user confirmation

## Problem Statement
[1-2 sentences describing the problem and who it affects]

## Requirements

### Must-Have
1. [R1: requirement with clear acceptance criterion]
2. [R2: requirement with clear acceptance criterion]
...

### Nice-to-Have
1. [requirement with acceptance criterion]
...

## Scope

### In Scope
- [specific deliverable]
...

### Out of Scope
- [explicitly excluded item with reason]
...

## Data Model Impact
- [entity changes, new fields, migrations needed]

## API Changes
- [new/modified endpoints, request/response shapes]

## UI Changes
- [new/modified pages, components, interactions]

## Edge Cases & Error Handling
1. [edge case] — [expected behavior]
2. ...

## Success Criteria
1. [measurable, testable criterion]
2. ...

## Constraints
- [technical, timeline, or compatibility constraints]

## Open Questions
- [anything still unresolved — should be empty if interview was thorough]
```

Present the spec to the user for final confirmation. If they approve, it's ready to pass to `/orchestrate` or `/plan`.

## Rules

- **Be concise in questions** — 1-2 sentences per question, not paragraphs
- **Don't repeat information** — if the user already stated something, reference it, don't ask again
- **Don't over-interview** — if the feature is straightforward, skip unnecessary rounds
- **Be opinionated** — propose sensible defaults for edge cases instead of asking "what should happen here?" for every possibility
- **Ground questions in code** — Round 2 questions should reference actual files and patterns you found, not hypothetical concerns
